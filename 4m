class Node: 
    def __init__(self, data): 
        self.data = data 
        self.left = None 
        self.right = None 
        self.height = 1   
 
def get_height(node): 
    if not node: 
        return 0 
    return node.height 
 
def get_balance(node): 
    if not node: 
        return 0 
    return get_height(node.left) - get_height(node.right) 
 
def right_rotate(y): 
    x = y.left 
    T2 = x.right 
 
    x.right = y 
    y.left = T2 
     
    y.height = 1 + max(get_height(y.left), get_height(y.right)) 
    x.height = 1 + max(get_height(x.left), get_height(x.right)) 
    return x 
 
def left_rotate(x): 
    y = x.right 
    T2 = y.left 
     
    y.left = x 
    x.right = T2 
     
    x.height = 1 + max(get_height(x.left), get_height(x.right)) 
    y.height = 1 + max(get_height(y.left), get_height(y.right)) 
    return y 
 
 
def insert(root, key): 
    if not root: 
        return Node(key) 
 
    if key < root.data: 
        root.left = insert(root.left, key) 
    elif key > root.data: 
        root.right = insert(root.right, key) 
    else: 
        return root   
 
    root.height = 1 + max(get_height(root.left), get_height(root.right)) 
    balance = get_balance(root) 
 
    if balance > 1 and key < root.left.data:  # LL 
        return right_rotate(root) 
    if balance < -1 and key > root.right.data:  # RR 
        return left_rotate(root) 
    if balance > 1 and key > root.left.data:  # LR 
        root.left = left_rotate(root.left) 
        return right_rotate(root) 
    if balance < -1 and key < root.right.data:  # RL 
        root.right = right_rotate(root.right) 
        return left_rotate(root) 
    return root 
 
def min_value_node(node): 
    current = node 
    while current.left: 
        current = current.left 
    return current 
 
def delete_node(root, key): 
    if not root: 
        return root 
    if key < root.data: 
        root.left = delete_node(root.left, key) 
    elif key > root.data: 
        root.right = delete_node(root.right, key) 
    else: 
        if not root.left or not root.right: 
            temp = root.left if root.left else root.right 
            root = temp   
        else: 
            temp = min_value_node(root.right) 
            root.data = temp.data 
            root.right = delete_node(root.right, temp.data) 
    if not root: 
        return root 
 
    root.height = 1 + max(get_height(root.left), get_height(root.right)) 
    balance = get_balance(root) 
 
    if balance > 1 and get_balance(root.left) >= 0:  # LL 
        return right_rotate(root) 
    if balance > 1 and get_balance(root.left) < 0:  # LR 
        root.left = left_rotate(root.left) 
        return right_rotate(root) 
    if balance < -1 and get_balance(root.right) <= 0:  # RR 
        return left_rotate(root) 
    if balance < -1 and get_balance(root.right) > 0:  # RL 
        root.right = right_rotate(root.right) 
        return left_rotate(root) 
    return root 
def inorder_traversal(root): 
    if root: 
        inorder_traversal(root.left) 
        print(root.data, end=' ') 
        inorder_traversal(root.right) 
 
def main(): 
    root = None 
    while True: 
        print("\n1. Insertion\n2. Deletion\n3. Display (In-order)\n4. Exit") 
        choice = input("Enter your choice: ") 
        if choice == '1': 
            value = int(input("Enter the value to insert: ")) 
            root = insert(root, value) 
        elif choice == '2': 
            value = int(input("Enter the value to delete: ")) 
            root = delete_node(root, value) 
        elif choice == '3': 
            print("In-order Traversal:", end=' ') 
            inorder_traversal(root) 
            print() 
        elif choice == '4': 
            print("Exiting...") 
            break 
        else: 
            print("Wrong selection! Try again.") 
if __name__ == "__main__": 
    main()
